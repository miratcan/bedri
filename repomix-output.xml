This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
public/
  vite.svg
src/
  assets/
    preact.svg
  components/
    Canvas.tsx
    Controls.tsx
    FontSettings.tsx
    ImageUpload.tsx
    Logs.tsx
    ProcessingSettings.tsx
    ProgressPanel.tsx
    ShadowSettings.tsx
    TextContent.tsx
    WorkerStatus.tsx
  app.css
  app.tsx
  constants.ts
  helpers.tsx
  index.css
  main.tsx
  types.ts
  vite-env.d.ts
  worker.ts
.gitignore
index.css
index.html
package.json
test_image.svg
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/preact.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="27.68" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 296"><path fill="#673AB8" d="m128 0l128 73.9v147.8l-128 73.9L0 221.7V73.9z"></path><path fill="#FFF" d="M34.865 220.478c17.016 21.78 71.095 5.185 122.15-34.704c51.055-39.888 80.24-88.345 63.224-110.126c-17.017-21.78-71.095-5.184-122.15 34.704c-51.055 39.89-80.24 88.346-63.224 110.126Zm7.27-5.68c-5.644-7.222-3.178-21.402 7.573-39.253c11.322-18.797 30.541-39.548 54.06-57.923c23.52-18.375 48.303-32.004 69.281-38.442c19.922-6.113 34.277-5.075 39.92 2.148c5.644 7.223 3.178 21.403-7.573 39.254c-11.322 18.797-30.541 39.547-54.06 57.923c-23.52 18.375-48.304 32.004-69.281 38.441c-19.922 6.114-34.277 5.076-39.92-2.147Z"></path><path fill="#FFF" d="M220.239 220.478c17.017-21.78-12.169-70.237-63.224-110.126C105.96 70.464 51.88 53.868 34.865 75.648c-17.017 21.78 12.169 70.238 63.224 110.126c51.055 39.889 105.133 56.485 122.15 34.704Zm-7.27-5.68c-5.643 7.224-19.998 8.262-39.92 2.148c-20.978-6.437-45.761-20.066-69.28-38.441c-23.52-18.376-42.74-39.126-54.06-57.923c-10.752-17.851-13.218-32.03-7.575-39.254c5.644-7.223 19.999-8.261 39.92-2.148c20.978 6.438 45.762 20.067 69.281 38.442c23.52 18.375 42.739 39.126 54.06 57.923c10.752 17.85 13.218 32.03 7.574 39.254Z"></path><path fill="#FFF" d="M127.552 167.667c10.827 0 19.603-8.777 19.603-19.604c0-10.826-8.776-19.603-19.603-19.603c-10.827 0-19.604 8.777-19.604 19.603c0 10.827 8.777 19.604 19.604 19.604Z"></path></svg>
</file>

<file path="src/components/Canvas.tsx">
import { RefObject } from 'preact';

interface CanvasProps {
  srcCanvasRef: RefObject<HTMLCanvasElement>;
  dstCanvasRef: RefObject<HTMLCanvasElement>;
  imageLoaded: boolean;
}

export function Canvas({ srcCanvasRef, dstCanvasRef, imageLoaded }: CanvasProps) {
  return (
    <>
      <canvas ref={dstCanvasRef} id="dstCanvas" />
      {imageLoaded && <canvas ref={srcCanvasRef} id="sCanvas" style="display: none;" />}
    </>
  );
}
</file>

<file path="src/components/Controls.tsx">
import { h } from 'preact';
import { Fittest } from '../types';

interface ControlsProps {
  onStart: () => void;
  onStop: () => void;
  onReset: () => void;
  onDownload: () => void;
  processing: boolean;
  imageLoaded: boolean;
  totalProcessed: number;
  linesCount: number;
}

export function Controls({ onStart, onStop, onReset, onDownload, processing, imageLoaded, totalProcessed, linesCount }: ControlsProps) {
  return (
    <div class="controls">
      <button onClick={onStart}>
        Start
      </button>
      <button onClick={onStop}>
        Stop
      </button>
      <button onClick={onReset}>
        Reset
      </button>
      <button onClick={onDownload}>
        Download
      </button>
      <progress id="progress" value={totalProcessed} max={linesCount} />
    </div>
  );
}
</file>

<file path="src/components/FontSettings.tsx">
import { FONT_FAMILIES } from '../constants';

interface FontSettingsProps {
  inputValues: {
    font: {
      family: string;
      minSize: string;
      maxSize: string;
      opacity: string;
      bold: string;
      shadow: {
        color: string;
        blur: string;
        offsetX: string;
        offsetY: string;
        enabled: string;
      };
    };
  };
  onInputChange: (e: Event) => void;
}

export function FontSettings({ inputValues, onInputChange }: FontSettingsProps) {
  return (
    <fieldset class="input-group">
      <legend>Font Settings</legend>
      <p class="fieldset-description">Configure how the text will appear. Adjust the font family, size range, opacity, and whether the text should be bold.</p>
      <div class="input-wrapper">
        <label for="fontFamilyInput">Font Family</label>
        <select
          name="font.family"
          value={inputValues.font.family}
          onChange={onInputChange}
          id="fontFamilyInput"
        >
          {FONT_FAMILIES.map(font => (
            <option value={font} key={font}>{font}</option>
          ))}
        </select>
      </div>

      <div class="input-wrapper">
        <label for="minSizeInput">Min Size</label>
        <input
          type="number"
          name="font.minSize"
          value={inputValues.font.minSize}
          onChange={onInputChange}
          placeholder="Min Size"
          id="minSizeInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="maxSizeInput">Max Size</label>
        <input
          type="number"
          name="font.maxSize"
          value={inputValues.font.maxSize}
          onChange={onInputChange}
          placeholder="Max Size"
          id="maxSizeInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="opacityInput">Opacity</label>
        <input
          type="number"
          name="font.opacity"
          value={inputValues.font.opacity}
          step="0.1"
          min="0"
          max="1"
          onChange={onInputChange}
          placeholder="Opacity"
          id="opacityInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="boldInput">Bold</label>
        <select
          name="font.bold"
          value={inputValues.font.bold}
          onChange={onInputChange}
          id="boldInput"
        >
          <option value="true">Yes</option>
          <option value="false">No</option>
        </select>
      </div>
    </fieldset>
  );
}
</file>

<file path="src/components/ImageUpload.tsx">
import { RefObject } from 'preact';

import { MAX_PIXEL_SIZE } from '../constants';
import { CurrentImage, DestinationImage } from '../types';
import { calcBrightness } from '../helpers';

interface ImageUploadProps {
  destinationCanvasRef: RefObject<HTMLCanvasElement>;
  destinationImage: DestinationImage | null;
  setDestinationImage: (source: DestinationImage | null) => void;
  setCurrentImage: (source: CurrentImage | null) => void;
}

export function ImageUpload({ 
  destinationCanvasRef, destinationImage, setDestinationImage, setCurrentImage
}: ImageUploadProps) {
  const onImgLoad = (img: HTMLImageElement) => {
    // Create temporary canvas for brightness calculation
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
    if (!tempCtx) return;

    // Draw image to temp canvas for brightness calculation
    tempCtx.drawImage(img, 0, 0);

    // Calculate brightness array
    const brightnessArray = calcBrightness(tempCtx, img.width, img.height);

    const _destination: DestinationImage = {
      size: {
        width: img.width,
        height: img.height,
      },
      bArray: brightnessArray,
      iData: tempCtx.getImageData(0, 0, img.width, img.height)
    };
    setDestinationImage(_destination);

    // Create blank black canvas for current image
    const blankCanvas = document.createElement('canvas');
    blankCanvas.width = img.width;
    blankCanvas.height = img.height;
    const blankCtx = blankCanvas.getContext('2d', { willReadFrequently: true });
    if (!blankCtx) return;

    // Fill with black
    blankCtx.fillStyle = 'black';
    blankCtx.fillRect(0, 0, img.width, img.height);

    const _current: CurrentImage = {
      bArray: new Float32Array(img.width * img.height), // All black pixels (0)
      iData: blankCtx.getImageData(0, 0, img.width, img.height)
    };
    setCurrentImage(_current);
  };

  const handleImageChange = (e: Event) => {
    const file = (e.target as HTMLInputElement).files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        if (img.width * img.height > MAX_PIXEL_SIZE) {
          alert(`Warning: Image dimensions (${img.width}x${img.height}) exceed recommended size. The app will work slow. Number of pixels: ${img.width * img.height}.`);
        }
        onImgLoad(img);
      };
      img.src = event.target?.result as string;
    };
    reader.readAsDataURL(file);
  };

  return (
    <div class="image-upload-container">
      <input
        type="file"
        onChange={handleImageChange}
        accept="image/*"
        id="fileInput"
        style="display: none"
      />
      <button 
        onClick={() => document.getElementById('fileInput')?.click()}
        class="upload-button"
      >
        {destinationImage ? 'Change Image' : 'Select Image'}
      </button>
      <canvas 
        ref={destinationCanvasRef}
        id="destinationCanvas" 
        width={destinationImage?.size.width || 100} 
        height={destinationImage?.size.height || 100}
      />
      {destinationImage && (
        <div class="image-info">
          <div>Dimensions: {destinationImage.size.width}x{destinationImage.size.height}px</div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/Logs.tsx">
import { h } from 'preact';

interface LogsProps {
  logs: string[];
}

export function Logs({ logs }: LogsProps) {
  return (
    <div class="logs">
      {logs.map((log, index) => (
        <div key={index} class="log-entry">
          {log}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/ProcessingSettings.tsx">
interface ProcessingSettingsProps {
  inputValues: {
    iterations: string;
    generations: string;
  };
  onInputChange: (e: Event) => void;
}

export function ProcessingSettings({ inputValues, onInputChange }: ProcessingSettingsProps) {
  return (
    <fieldset class="input-group">
      <legend>Processing Settings</legend>
      <p class="fieldset-description">Control how the genetic algorithm works. More iterations will find better placements for each text block, while more generations will add more text blocks to the final image.</p>
      <div class="input-wrapper">
        <label for="iterationsInput">Iterations</label>
        <input
          type="number"
          name="iterations"
          value={inputValues.iterations}
          onChange={onInputChange}
          placeholder="Iterations"
          id="iterationsInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="generationsInput">Generations</label>
        <input
          type="number"
          name="generations"
          value={inputValues.generations}
          onChange={onInputChange}
          placeholder="Number of generations"
          id="generationsInput"
        />
      </div>
    </fieldset>
  );
}
</file>

<file path="src/components/ProgressPanel.tsx">
import { WorkerProcessStats } from '../types';

interface ProgressPanelProps {
  processStats: WorkerProcessStats;
}

export function ProgressPanel({ processStats }: ProgressPanelProps) {
  return (
    <div class="progress-panel">
      <h3 class="progress-title">Processing Status</h3>
      {Object.entries(processStats).map(([id, stats]) => {
        const percentage = Math.round((stats.processed / stats.total) * 100) || 0;
        return (
          <div key={id} class="progress-item">
            <span class="progress-label">Worker {id}</span>
            <div class="progress-bar-container">
              <div class="progress-bar" style={{ width: `${percentage}%` }}></div>
            </div>
            <span class="progress-stats">{stats.processed}/{stats.total} ({percentage}%)</span>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/ShadowSettings.tsx">
interface ShadowSettingsProps {
  inputValues: {
    font: {
      shadow: {
        color: string;
        blur: string;
        offsetX: string;
        offsetY: string;
        enabled: string;
      };
    };
  };
  onInputChange: (e: Event) => void;
}

export function ShadowSettings({ inputValues, onInputChange }: ShadowSettingsProps) {
  return (
    <fieldset class="input-group">
      <legend>Shadow Settings</legend>
      <p class="fieldset-description">Add depth to your text with shadow effects. Enable shadows and adjust their appearance with color, blur, and offset settings.</p>
      <div class="input-wrapper">
        <label for="shadowEnabledInput">Enabled</label>
        <select
          name="font.shadow.enabled"
          value={inputValues.font.shadow.enabled}
          onChange={onInputChange}
          id="shadowEnabledInput"
        >
          <option value="true">Yes</option>
          <option value="false">No</option>
        </select>
      </div>

      <div class="input-wrapper">
        <label for="shadowColorInput">Color</label>
        <input
          type="color"
          name="font.shadow.color"
          value={inputValues.font.shadow.color}
          onChange={onInputChange}
          id="shadowColorInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="shadowBlurInput">Blur</label>
        <input
          type="number"
          name="font.shadow.blur"
          value={inputValues.font.shadow.blur}
          onChange={onInputChange}
          placeholder="Shadow Blur"
          id="shadowBlurInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="shadowOffsetXInput">Offset X</label>
        <input
          type="number"
          name="font.shadow.offsetX"
          value={inputValues.font.shadow.offsetX}
          onChange={onInputChange}
          placeholder="Shadow Offset X"
          id="shadowOffsetXInput"
        />
      </div>

      <div class="input-wrapper">
        <label for="shadowOffsetYInput">Offset Y</label>
        <input
          type="number"
          name="font.shadow.offsetY"
          value={inputValues.font.shadow.offsetY}
          onChange={onInputChange}
          placeholder="Shadow Offset Y"
          id="shadowOffsetYInput"
        />
      </div>
    </fieldset>
  );
}
</file>

<file path="src/components/TextContent.tsx">
import { USE_TYPES } from '../constants';

interface TextContentProps {
  inputValues: {
    blocks: string;
    useType: string;
  };
  onInputChange: (e: Event) => void;
}

export function TextContent({ inputValues, onInputChange }: TextContentProps) {
  return (
    <fieldset class="input-group">
      <legend>Text Content</legend>
      <p class="fieldset-description">Enter the text blocks that will be used to draw the image. Each line will be treated as a separate block that can be placed and rotated independently.</p>
      <div class="input-wrapper">
        <label for="useTypeInput">Use</label>
        <select
          name="useType"
          value={inputValues.useType}
          onChange={onInputChange}
          id="useTypeInput"
        >
          {USE_TYPES.map(type => (
            <option value={type.value} key={type.value}>{type.label}</option>
          ))}
        </select>
      </div>
      <div class='input-wrapper'>
        <label for="blocksInput">Text Blocks</label>
        <textarea
          name="blocks"
          value={inputValues.blocks}
          onChange={onInputChange}
          placeholder="Enter text blocks (one per line)"
          rows={5}
          id="blocksInput"
        />
      </div>
   </fieldset>
  );
}
</file>

<file path="src/components/WorkerStatus.tsx">
import { h } from 'preact';

interface WorkerStatusProps {
  activeWorkers: number;
  totalWorkers: number;
  totalProcessed: number;
  linesCount: number;
}

const WorkerStatus = ({ activeWorkers, totalWorkers, totalProcessed, linesCount }: WorkerStatusProps) => {
  return (
    <div class="worker-status">
      <div class="worker-status-header">
        <h3>Worker Status</h3>
        <div class="progress-info">
          {totalProcessed} / {linesCount} lines processed
        </div>
      </div>
      <div class="worker-indicators">
        {Array.from({ length: totalWorkers }).map((_, index) => (
          <div 
            class={`worker-indicator ${index < activeWorkers ? 'active' : ''}`}
            title={`Worker ${index + 1} - ${index < activeWorkers ? 'Processing' : 'Idle'}`}
          >
            <div class="worker-icon">[ ]</div>
            <div class="worker-number">Worker {index + 1}</div>
            <div class="worker-status-text">{index < activeWorkers ? 'Processing' : 'Idle'}</div>
          </div>
        ))}
      </div>
    </div>
  );
};

export { WorkerStatus };
</file>

<file path="src/app.css">
@font-face {
  font-family: Dos;
  src: url(https://mirat.dev/dos.ttf);
}

:root {
  --c0: #000000;
  --c1: #000080;
  --c2: #00aaaa;
  --c3: #0f110f;
  --c4: #aa00aa;
  --c5: #aa0000;
  --c6: #aa5500;
  --c7: #aaaaaa;
  --c8: #555555;
  --c9: #5555ff;
  --c10: #1fdbdb;
  --c12: #55ff55;
  --c12: #ff55ff;
  --c13: #ff5555;
  --c14: #ffff55;
  --c15: #ffffff;
  --ln: 2px;
  --gap: 1rem;
  --fs: 16px;
  --lh: 24px;
}

html,
body {
  margin: 0;
  padding: 0;
}

body {
  background: var(--c0);
  color: var(--c7);
  font-family: 'Dos', monospace;
  font-size: var(--fs);
  line-height: var(--lh);
  vertical-align: center;
  font-smooth: never;
  -webkit-font-smoothing: none;
  letter-spacing: -1px;
}

h1, h2, h3, h4, h5, legend {
  font-size: inherit;
  font-weight: normal;
  color: var(--c14);
}

.wrapper {
  display: grid;
  grid-template-columns: 1fr 1fr 300px;
  grid-template-rows: auto auto auto 1fr;
  gap: var(--gap);
  padding: var(--gap);
  max-width: 1600px;
  margin: 0 auto;
}

.column {
  flex: 1;
}

.column:last-child {
  align-self: flex-start;
}

.description {
  grid-column: 1 / 3;
  grid-row: 1;
  margin-bottom: var(--gap);
}

.description p {
  margin: 0;
}

.control-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--gap);
  margin-bottom: var(--gap);
}

.canvas-container {
  grid-column: 2;
  grid-row: 2;
  display: grid;
  gap: var(--gap);
}

.inputs {
  grid-column: 1;
  grid-row: 2 / span 3;
  display: grid;
  gap: var(--gap);
  align-content: start;
}

#dstCanvas {
  height: auto;
  border: 2px solid var(--c8);
  justify-self: start;
}

.ad-container {
  grid-column: 3;
  grid-row: 1 / span 4;
  padding: var(--gap);
  background: var(--c3);
  border: 2px solid var(--c8);
  display: flex;
  flex-direction: column;
  gap: var(--gap);
}

.ad-placeholder {
  background: var(--c0);
  border: 2px dashed var(--c8);
  padding: 1rem;
  text-align: center;
  color: var(--c7);
  min-height: 250px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.image-upload-container {
  display: grid;
  gap: var(--gap);
}

.upload-button {
  padding: 8px 16px;
  background-color: var(--c0);
  color: var(--c7);
  border: 2px solid var(--c8);
  cursor: pointer;
  text-align: center;
}

.upload-button:hover:not(:disabled) {
  background: var(--c3);
  color: var(--c15);
}

.preview-container {
  display: grid;
  gap: var(--gap);
  justify-content: center;
}

#currentCanvas {
  border: 2px solid var(--c8);
  justify-self: center;
  background: var(--c0);
}

.image-info {
  font-size: var(--fs);
  color: var(--c7);
  text-align: center;
  padding: 0.5rem;
  background: var(--c0);
  border: 1px solid var(--c8);
}

label {
  display: block;
  margin-bottom: 0.5rem;
  color: var(--c7);
  font-size: var(--fs);
}

input, textarea, select, button {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  background: var(--c0);
  color: var(--c7);
  border: 2px solid var(--c8);
  padding: 0.5rem;
  margin: 0;
  display: block;
  box-sizing: border-box;
  width: 100%;
}

input:focus, textarea:focus, select:focus {
  outline: none;
}

button {
  background: var(--c0);
  color: var(--c7);
  border: 2px solid var(--c8);
  padding: 0.5rem;
  cursor: pointer;
  text-align: center;
}

button:not(:disabled) {
  background: var(--c0);
  color: var(--c7);
}

button:hover:not(:disabled) {
  background: var(--c3);
  color: var(--c15);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

input[type="checkbox"], input[type="radio"] {
  width: auto;
  display: inline-block;
  margin-right: 0.5rem;
}

input[type="range"] {
  -webkit-appearance: none;
  height: 2px;
  background: var(--c8);
  padding: 0;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: var(--c7);
  border-radius: 50%;
  cursor: pointer;
}

.button-group {
  display: flex;
  gap: var(--gap);
}

.button-group > * {
  flex: 1;
}

progress {
  width: 100%;
  height: 20px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--c0);
  border: 2px solid var(--c8);
}

progress::-webkit-progress-bar {
  background: var(--c0);
}

progress::-webkit-progress-value {
  background: var(--c7);
}

.control-grid #startButton {
  grid-column: 1;
  grid-row: 1;
}

.control-grid #stopButton {
  grid-column: 2;
  grid-row: 1;
}

.control-grid #resetButton {
  grid-column: 1;
  grid-row: 2;
}

.control-grid #progress {
  grid-column: 1 / -1;
  grid-row: 3;
}

.control-grid #downloadButton {
  grid-column: 2;
  grid-row: 2;
}

canvas {
  width: 100%;
  height: auto;
  border: 2px solid var(--c8);
}

@media only screen and (max-width: 500px) {
  .wrapper {
    grid-template-columns: 1fr;
  }

  .control-grid {
    grid-template-columns: 1fr;
  }

  .control-grid #startButton,
  .control-grid #stopButton,
  .control-grid #resetButton,
  .control-grid #downloadButton {
    grid-column: 1;
  }

  .control-grid #startButton { grid-row: 1; }
  .control-grid #stopButton { grid-row: 2; }
  .control-grid #resetButton { grid-row: 3; }
  .control-grid #downloadButton { grid-row: 4; }
  .control-grid #progress { grid-row: 5; }
}

.input-wrapper {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
  gap: 1rem;
}

.input-wrapper label {
  min-width: 100px;
  text-align: right;
  margin-bottom: 0;
}

.input-wrapper input,
.input-wrapper select,
.input-wrapper textarea {
  flex: 1;
  padding: 0.5rem;
  border: 2px solid var(--c8);
  background: var(--c0);
  color: var(--c7);
}

.fieldset-description {
  color: var(--c7);
  font-size: var(--fs);
  margin: 0 0 1rem 0;
  line-height: 1.4;
  opacity: 0.9;
}

.input-group {
  border: 2px solid var(--c8);
  border-radius: 4px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  background: var(--c0);
}

.input-group legend {
  padding: 0 0.5rem;
  margin-bottom: 0.5rem;
}

textarea {
  width: 100%;
  min-height: 100px;
  resize: vertical;
}

.worker-status {
  margin: 1rem 0;
  padding: 1rem;
  background: var(--c0);
  border: 2px solid var(--c8);
  border-radius: 0;
}

.worker-status-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  border-bottom: 2px solid var(--c8);
  padding-bottom: 0.5rem;
}

.progress-info {
  font-size: var(--fs);
  color: var(--c7);
}

.worker-indicators {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 0.5rem;
}

.worker-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem;
  background: var(--c0);
  border: 2px solid var(--c8);
  min-width: 120px;
}

.worker-indicator.active {
  background: var(--c3);
  border-color: var(--c7);
}

.worker-indicator.active .worker-icon {
  color: var(--c10);
}

.worker-icon {
  font-family: 'Dos', monospace;
  font-size: var(--fs);
  color: var(--c8);
}

.worker-number {
  font-size: var(--fs);
  color: var(--c7);
  font-weight: normal;
}

.worker-status-text {
  font-size: var(--fs);
  color: var(--c8);
  text-transform: uppercase;
}

@media only screen and (max-width: 500px) {
  .worker-indicators {
    grid-template-columns: 1fr;
  }
}

.logs {
  grid-column: 2;
  grid-row: 3;
  background: var(--c0);
  overflow-y: auto;
  padding: var(--gap);
  margin-top: var(--gap);
}

.log-entry:nth-child(1)  { opacity: .1 }
.log-entry:nth-child(2)  { opacity: .2 }
.log-entry:nth-child(3)  { opacity: .3 }
.log-entry:nth-child(4)  { opacity: .4 }
.log-entry:nth-child(5)  { opacity: .5 }
.log-entry:nth-child(6)  { opacity: .6 }
.log-entry:nth-child(7)  { opacity: .7 }
.log-entry:nth-child(8)  { opacity: .8 }
.log-entry:nth-child(9)  { opacity: .9 }
.log-entry:nth-child(10) { opacity: 1 }

.log-entry {
  padding: 4px 0;
  color: var(--c7);
}

.log-entry:last-child {
  border-bottom: none;
}

.progress {
  margin: 20px 0;
  padding: 15px;
  background-color: #f5f5f5;
  border-radius: 8px;
}

.progress h3 {
  margin: 0 0 10px 0;
  color: #333;
}

.progress div {
  margin: 5px 0;
  font-size: 14px;
  color: #666;
}

.controls {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}

.controls button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  background-color: #4CAF50;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s;
}

.controls button:hover {
  background-color: #45a049;
}

.controls button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.controls button:nth-child(2) {
  background-color: #f44336;
}

.controls button:nth-child(2):hover {
  background-color: #da190b;
}

.controls button:nth-child(3) {
  background-color: #2196F3;
}

.controls button:nth-child(3):hover {
  background-color: #0b7dda;
}

.controls button:nth-child(4) {
  background-color: #9C27B0;
}

.controls button:nth-child(4):hover {
  background-color: #7b1fa2;
}

.progress-container {
  grid-column: 2;
  grid-row: 3;
  background: var(--c3);
  border: 2px solid var(--c8);
  padding: var(--gap);
}

.progress-panel {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.progress-title {
  margin: 0;
  color: var(--c14);
}

.progress-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem;
}

.progress-label {
  min-width: 80px;
  color: var(--c7);
}

.progress-bar-container {
  flex: 1;
  height: 12px;
  background: var(--c0);
  border: 1px solid var(--c8);
}

.progress-bar {
  height: 100%;
  background: var(--c7);
  transition: width 0.3s ease;
}

.progress-stats {
  min-width: 100px;
  text-align: right;
  color: var(--c7);
}
</file>

<file path="src/app.tsx">
import { useEffect, useRef, useState } from 'preact/hooks';
import './app.css';
import { FontSettings } from './components/FontSettings';
import { ImageUpload } from './components/ImageUpload';
import { ProcessingSettings } from './components/ProcessingSettings';
import { ShadowSettings } from './components/ShadowSettings';
import { TextContent } from './components/TextContent';
import { DEFAULT_BLOCKS, MAX_ACTIVE_WORKERS } from './constants';
import { Options, DestinationImage, WorkerMessage, WorkerProcessStats, Candidate, UpdateMessage, BaseMessage, DoneMessage, ErrorMessage, CurrentImage, InitMessage } from './types';
import { ProgressPanel } from './components/ProgressPanel';
import { Controls } from './components/Controls';


export function App() {
  const [inputValues, setInputValues] = useState({
    blocks: DEFAULT_BLOCKS,
    useType: 'lines',
    font: {
      family: 'Arial',
      minSize: '10',
      maxSize: '50',
      opacity: '0.5',
      bold: 'false',
      shadow: {
        color: '#000000',
        blur: '0',
        offsetX: '0',
        offsetY: '0',
        enabled: 'false'
      }
    },
    iterations: '100',
    generations: '2500'
  });
  const [processing, setProcessing] = useState(false);
  const [currentGeneration, setCurrentGeneration] = useState<number>(0);
  const [processStats, setProcessStats] = useState<WorkerProcessStats>();
  const [champions, setChampions] = useState<Record<number, Candidate>>({});
  const [currentImage, setCurrentImage] = useState<CurrentImage | null>(null);
  const [destinationImage, setDestinationImage] = useState<DestinationImage | null>(null);

  const workersRef = useRef<Array<Worker>>([]);
  const currentCanvasRef = useRef<HTMLCanvasElement>(null);
  const destinationCanvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    initializeWorkerPool()
  }, [])

  useEffect(() => {
    // Find the champion of champions and draw it to the canvas
    if (Object.keys(champions).length > 0 && destinationCanvasRef.current && destinationImage) {
      // Find the champion with the highest score
      const championArray = Object.values(champions) as Candidate[];
      const bestChampion = championArray.reduce((best, current) => {
        if (!best || (current.score ?? 0) > (best.score ?? 0)) {
          return current;
        }
        return best;
      }, null as Candidate | null);
      
      if (bestChampion) {
        // Draw the best champion to the destination canvas
        const ctx = currentCanvasRef.current!.getContext('2d') as CanvasRenderingContext2D;
        if (ctx) {
          
          // Draw the champion
          ctx.save();
          ctx.font = `${bestChampion.s}px ${inputValues.font.family}`;
          ctx.fillStyle = `rgba(255, 255, 255, ${bestChampion.o})`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Apply shadow if enabled
          if (inputValues.font.shadow.enabled === 'true') {
            ctx.shadowColor = inputValues.font.shadow.color;
            ctx.shadowBlur = parseInt(inputValues.font.shadow.blur);
            ctx.shadowOffsetX = parseInt(inputValues.font.shadow.offsetX);
            ctx.shadowOffsetY = parseInt(inputValues.font.shadow.offsetY);
          }
          
          // Draw the text
          ctx.fillText(bestChampion.t, bestChampion.x, bestChampion.y);
          ctx.restore();
          
          // Update current generation
          setCurrentGeneration(prev => prev + 1);
          
          // Update current image with the new canvas content
          if (destinationCanvasRef.current) {
            const imageData = ctx.getImageData(0, 0, destinationImage.size.width, destinationImage.size.height);
            setCurrentImage({
              iData: imageData,
              size: {
                width: destinationImage.size.width,
                height: destinationImage.size.height
              }
            });
            
            // If still processing, initialize workers with the new current image
            if (processing) {
              const options = readOptions();
              for (let i = 0; i < MAX_ACTIVE_WORKERS; i++) {
                const worker = workersRef.current[i];
                if (!worker) {
                  console.log(`Error: Worker ${i} not found`);
                  continue;
                }
                const nofCandidates = Math.floor(options.iterations / MAX_ACTIVE_WORKERS) +
                  (i < options.iterations % MAX_ACTIVE_WORKERS ? 1 : 0);
                worker.postMessage({
                  action: 'init',
                  workerId: i,
                  timestamp: Date.now(),
                  currentImage: {
                    iData: imageData,
                    size: {
                      width: destinationImage.size.width,
                      height: destinationImage.size.height
                    }
                  },
                  destinationImage: destinationImage,
                  options: options,
                  nofCandidates: nofCandidates
                });
              }
            }
          }
        }
      }
    }


  }, [champions])

  useEffect(() => {
    // Update the current canvas when currentImage changes
    if (currentImage && currentCanvasRef.current) {
      const ctx = currentCanvasRef.current.getContext('2d');
      if (ctx) {
        // Make sure canvas dimensions match the image data
        if (currentCanvasRef.current.width !== currentImage.iData.width ||
          currentCanvasRef.current.height !== currentImage.iData.height) {
          currentCanvasRef.current.width = currentImage.iData.width;
          currentCanvasRef.current.height = currentImage.iData.height;
        }
        // Draw the current image data to the canvas
        ctx.putImageData(currentImage.iData, 0, 0);
      }
    }
  }, [currentImage])

  useEffect(() => {
    // Redraw the destination canvas when destinationImage changes
    if (destinationImage && destinationCanvasRef.current) {
      const ctx = destinationCanvasRef.current.getContext('2d');
      if (ctx) {
        // Make sure canvas dimensions match the image data
        if (destinationCanvasRef.current.width !== destinationImage.size.width ||
          destinationCanvasRef.current.height !== destinationImage.size.height) {
          destinationCanvasRef.current.width = destinationImage.size.width;
          destinationCanvasRef.current.height = destinationImage.size.height;
        }
        // Draw the destination image data to the canvas
        ctx.putImageData(destinationImage.iData, 0, 0);
      }
    }
  }, [destinationImage])

  const handleInputChange = (e: Event) => {
    const target = e.target as HTMLInputElement | HTMLTextAreaElement;
    const [, subsection, field] = target.name.split('.');

    if (subsection && field) {
      setInputValues(prev => ({
        ...prev,
        font: {
          ...prev.font,
          shadow: {
            ...prev.font.shadow,
            [field]: target.value
          }
        }
      }));
    } else if (subsection) {
      setInputValues(prev => ({
        ...prev,
        font: {
          ...prev.font,
          [subsection]: target.value
        }
      }));
    } else {
      setInputValues(prev => ({
        ...prev,
        [target.name]: target.value
      }));
    }
  };

  const readOptions = (): Options => {
    const blocks = inputValues.useType === 'words'
      ? inputValues.blocks.trim().split(/\s+/)
      : inputValues.blocks.trim().split(/\n+/);

    return {
      blocks,
      font: {
        family: inputValues.font.family,
        minSize: parseInt(inputValues.font.minSize),
        maxSize: parseInt(inputValues.font.maxSize),
        opacity: parseFloat(inputValues.font.opacity),
        bold: inputValues.font.bold === 'true',
        shadow: {
          color: inputValues.font.shadow.color,
          blur: parseInt(inputValues.font.shadow.blur),
          offsetX: parseInt(inputValues.font.shadow.offsetX),
          offsetY: parseInt(inputValues.font.shadow.offsetY),
          enabled: inputValues.font.shadow.enabled === 'true'
        }
      },
      iterations: parseInt(inputValues.iterations),
      generations: parseInt(inputValues.generations)
    };
  };

  const downloadImage = () => {
    if (destinationCanvasRef.current) {
      const link = document.createElement("a");
      link.href = destinationCanvasRef.current.toDataURL("image/png");
      link.download = "textdraw.png";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  const initializeWorkerPool = () => {
    // Clear existing workers if any
    workersRef.current.forEach(worker => {
      if (worker) {
        worker.terminate();
      }
    });
    workersRef.current = [];

    for (let i = 0; i < MAX_ACTIVE_WORKERS; i++) {
      console.log(`Initializing worker: ${i}`);
      try {
        const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
        worker.onmessage = (e: MessageEvent<WorkerMessage>) => {
          const { action, workerId } = e.data;

          if ('reason' in e.data) {
            console.log(`Worker ${workerId}: Error - ${e.data.reason}`);
            return;
          }

          if (workerId === undefined) {
            console.log('Worker message received without ID');
            return;
          }

          switch (action) {
            case 'ready':
              console.log(`Worker ${workerId} initialized and ready.`);
              setProcessStats(prevState => {
                const old = prevState ?? {};
                return {
                  ...old,
                  [workerId]: {
                    total: 0,
                    processed: 0
                  }
                };
              });
              break;
            case 'initialized':
              if (!processing) {
                workersRef.current[workerId]?.postMessage({
                  action: 'process',
                  timestamp: Date.now(),
                  workerId
                });
              }
              break;
            case 'update':
              const updateMessage = e.data as UpdateMessage & BaseMessage;
              setProcessStats(prevState => {
                const old = prevState ?? {};
                return {
                  ...old,
                  [workerId]: {
                    total: updateMessage.total,
                    processed: updateMessage.processed
                  }
                };
              });
              break;
            case 'done':
              const doneMessage = e.data as DoneMessage & BaseMessage;
              setChampions(prevState => ({
                ...prevState,
                [workerId]: doneMessage.fittest.candidate as Candidate
              }));
              break;
            case 'error':
              const errorMessage = e.data as ErrorMessage & BaseMessage;
              console.log(`Worker ${workerId}: Error - ${errorMessage.reason}`);
              break;
          }
        };

        worker.onerror = (error) => {
          console.log(`Worker error: ${error.message}`);
        };

        worker.postMessage({
          action: 'ignite',
          workerId: i,
          timestamp: Date.now()
        });
        workersRef.current[i] = worker;
      } catch (error) {
        console.log(`Failed to initialize worker ${i}: ${error}`);
      }
    }
  };

  const startProcessing = () => {
    if (processing) {
      return;
    }
    if (!destinationImage) {
      console.log("Error: Please upload an image first");
      alert("Please upload an image first.");
      return;
    }
    if (!workersRef.current || workersRef.current.length === 0) {
      console.log("Error: Workers not initialized");
      alert("Workers are not initialized yet.");
      return;
    }
    const options = readOptions();
    if (options.blocks.length === 0) {
      console.log("Error: No text blocks provided");
      alert("Please enter some text first.");
      return;
    }
    if (options.font.minSize >= options.font.maxSize) {
      console.log("Error: Invalid font size range");
      alert("Minimum font size must be less than maximum font size.");
      return;
    }
    setProcessing(true);
    setCurrentGeneration(0);
    setProcessStats({});
    setChampions({});
    for (let i = 0; i < MAX_ACTIVE_WORKERS; i++) {
      const worker = workersRef.current[i];
      if (!worker) {
        console.log(`Error: Worker ${i} not found`);
        continue;
      }
      const nofCandidates = Math.floor(options.iterations / MAX_ACTIVE_WORKERS) +
        (i < options.iterations % MAX_ACTIVE_WORKERS ? 1 : 0);
      worker.postMessage({
        action: 'init',
        workerId: i,
        timestamp: Date.now(),
        currentImage: currentImage,
        destinationImage: destinationImage,
        options: options,
        nofCandidates: nofCandidates
      });
    }
  };

  const stopProcessing = () => {
    console.log("Processing stopped by user");
    setProcessing(false);
    workersRef.current.forEach(worker => {
      worker.terminate();
    });
    initializeWorkerPool();
  };

  const reset = () => {
    console.log("Reset requested - clearing canvas");
    setProcessing(false);
    setCurrentGeneration(0);
    setProcessStats(undefined);
    setChampions({});
    if (destinationCanvasRef.current) {
      const ctx = destinationCanvasRef.current.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, destinationCanvasRef.current.width, destinationCanvasRef.current.height);
      }
    }
  };

  // Add progress visualization
  useEffect(() => {
    if (!destinationCanvasRef.current || !destinationImage || Object.keys(champions).length === 0) return;

    const ctx = destinationCanvasRef.current.getContext('2d');
    if (!ctx) return;

    // Clear the canvas
    ctx.clearRect(0, 0, destinationImage.size.width, destinationImage.size.height);

    // Draw each champion
    Object.values(champions).forEach(champion => {
      if (!champion) return;

      ctx.save();
      ctx.font = `${champion.s}px ${inputValues.font.family}`;
      ctx.fillStyle = `rgba(255, 255, 255, ${champion.o})`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Apply shadow if enabled
      if (inputValues.font.shadow.enabled === 'true') {
        ctx.shadowColor = inputValues.font.shadow.color;
        ctx.shadowBlur = parseInt(inputValues.font.shadow.blur);
        ctx.shadowOffsetX = parseInt(inputValues.font.shadow.offsetX);
        ctx.shadowOffsetY = parseInt(inputValues.font.shadow.offsetY);
      }

      // Apply rotation and draw text
      ctx.translate(champion.x, champion.y);
      ctx.rotate(champion.r);
      ctx.fillText(champion.t, 0, 0);
      ctx.restore();
    });
  }, [champions, destinationImage, inputValues.font]);

  useEffect(() => {
    return () => {
      workersRef.current?.forEach((worker: Worker) => worker.terminate());
    };
  }, []);

  return (
    <div class="wrapper">
      <div class="description">
        <p>Upload an image and enter text lines. The app will generate a text-based representation of the image using the provided text.</p>
      </div>

      <div class="canvas-container">
        <canvas ref={currentCanvasRef} id="currentCanvas" />
      </div>

      <div class="progress-container">
        {processStats && <ProgressPanel processStats={processStats} />}
      </div>

      <div class="inputs">
        <ImageUpload 
          destinationCanvasRef={destinationCanvasRef}
          destinationImage={destinationImage}
          setDestinationImage={setDestinationImage}
          setCurrentImage={setCurrentImage}
        />

        <TextContent
          inputValues={inputValues}
          onInputChange={handleInputChange}
        />

        <FontSettings
          inputValues={inputValues}
          onInputChange={handleInputChange}
        />

        <ShadowSettings
          inputValues={inputValues}
          onInputChange={handleInputChange}
        />

        <ProcessingSettings
          inputValues={inputValues}
          onInputChange={handleInputChange}
        />
        <Controls
          onStart={startProcessing}
          onStop={stopProcessing}
          onReset={reset}
          onDownload={downloadImage}
          processing={processing}
          imageLoaded={!!destinationImage}
          totalProcessed={processStats ? Object.values(processStats).reduce((sum, stat) => sum + stat.processed, 0) : 0}
          linesCount={processStats ? Object.values(processStats).reduce((sum, stat) => sum + stat.total, 0) : 0}
        />
      </div>

      <div class="ad-container">
        <div class="ad-placeholder">
          Sponsor
        </div>
        <div class="ad-placeholder">
          Sponsor
        </div>
        <div class="ad-placeholder">
          Sponsor
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/constants.ts">
export const MAX_PIXEL_SIZE = 1000000;
export const MAX_ACTIVE_WORKERS = navigator.hardwareConcurrency || 4;

export const FONT_FAMILIES = [
  'Arial',
  'Times New Roman',
  'Courier New',
  'Georgia',
  'Verdana',
  'Helvetica',
  'Impact',
  'Comic Sans MS'
];

export const USE_TYPES = [
  { value: 'lines', label: 'Lines' },
  { value: 'words', label: 'Words' }
];

export const DEFAULT_BLOCKS = `
Lorem ipsum dolor sit amet
consectetur adipiscing elit
sed do eiusmod tempor
incididunt ut labore
et dolore magna aliqua
Ut enim ad minim veniam
quis nostrud exercitation
ullamco laboris nisi
ut aliquip ex ea commodo
consequat Duis aute irure
dolor in reprehenderit
in voluptate velit esse
cillum dolore eu fugiat
nulla pariatur Excepteur
sint occaecat cupidatat
non proident sunt in
culpa qui officia deserunt
mollit anim id est laborum
`.trim();
</file>

<file path="src/helpers.tsx">
import { Width, Height, Candidate, DestinationImage, Options, CurrentImage } from './types';

type CanvasContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;

/**
 * Calculates the brightness of each pixel in a canvas context.
 * 
 * This function extracts pixel data from the canvas context and computes
 * a brightness value for each pixel using the standard luminance formula:
 * Brightness = 0.299*R + 0.587*G + 0.114*B
 * 
 * Luminance formula: https://stackoverflow.com/q/596216
 * 
 * The result is a Float32Array where each element represents the brightness
 * of a corresponding pixel in the image, with values ranging from 0 (black)
 * to 255 (white).
 * 
 * @param ctx - The canvas rendering context containing the image
 * @param w - Width of the image
 * @param h - Height of the image
 * @returns A Float32Array containing brightness values for each pixel
 */
export const calcBrightness = (ctx: CanvasContext, w: Width, h: Height): Float32Array => {
  const pixelData = ctx.getImageData(0, 0, w, h).data;
  const totalPixels = w * h;
  const result = new Float32Array(totalPixels);
  for (let i = 0; i < totalPixels; i++) {
    const pixelIndex = i * 4;
    const r = pixelData[pixelIndex];
    const g = pixelData[pixelIndex + 1];
    const b = pixelData[pixelIndex + 2];
    result[i] = 0.299 * r + 0.587 * g + 0.114 * b;
  }
  return result;
};

/**
 * Generates a random color in hsla color space. 
 * 
 * @param opacity: A number between 0 and 1 that defines opacity of the color.
 */
export const randColor = (opacity: number): string => {
  const h = Math.floor(Math.random() * 360);
  const s = Math.floor(Math.random() * 100);
  const l = Math.floor(Math.random() * 100);
  return `hsla(${h}, ${s}%, ${l}%, ${opacity})`;
};


export const generateCandidate = (destination: DestinationImage, options: Options): Candidate => {
    // Generate a random candidate for text placement
    // This function creates a single candidate with randomized properties
    // based on the provided options and destination image dimensions.
    // 
    // The candidate includes:
    // - A randomly selected text block from the options
    // - Font size within the min/max range specified in options
    // - Random position within the destination image boundaries
    // - Random color using randColor function
    // - Random rotation between -/2 and /2 radians
    
    const randomIndex = Math.floor(Math.random() * options.blocks.length);
    const randomText = options.blocks[randomIndex];
    return {
        text: randomText,
        size: Math.random() * (options.font.maxSize - options.font.minSize) + options.font.minSize,
        position: {
          x: Math.random() * destination.size.width,
          y: Math.random() * destination.size.height,
        },
        color: randColor(options.font.opacity),
        rotation: Math.random() * Math.PI - Math.PI / 2,
    }
}

export const generateCandidates = (destination: DestinationImage, options: Options, nofCandidates: number): Candidate[] => {
    return [...Array(nofCandidates)].map(() => generateCandidate(destination, options));
}

/**
 * Calculates the fitness score of a candidate by comparing its rendered brightness
 * with the target image's brightness.
 * 
 * The fitness score is calculated as the inverse of the mean squared error (MSE)
 * between the candidate's brightness and the target image's brightness.
 * A higher score indicates a better match.
 * 
 * @param candidate - The candidate text placement to evaluate
 * @param destinationImage - The source image data to compare against
 * @returns The fitness score of the candidate
 */
export const calcFitness = (
    currentImage: CurrentImage | undefined,
    candidate: Candidate,
    destinationImage: DestinationImage,
    options: Options
): number => {
    // Create a temporary canvas to render the candidate
    const canvas = new OffscreenCanvas(destinationImage.size.width, destinationImage.size.height);
    const ctx = canvas.getContext('2d');
    if (!ctx) return 0;

    // Clear the canvas
    if (currentImage) {
      ctx.putImageData(currentImage.iData, destinationImage.size.width, destinationImage.size.height);
    } else {
      ctx.fillStyle = 'black';
      ctx.clearRect(0, 0, destinationImage.size.width, destinationImage.size.height);
    }

    // Set up text rendering
    const fontWeight = options.font.bold ? 'bold' : 'normal';
    ctx.font = `${fontWeight} ${candidate.size}px ${options.font.family}`;
    ctx.fillStyle = candidate.color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Apply rotation
    ctx.translate(candidate.position.x, candidate.position.y);
    ctx.rotate(candidate.rotation);
    ctx.fillText(candidate.text, 0, 0);
    ctx.rotate(-candidate.rotation);
    ctx.translate(-candidate.position.x, -candidate.position.y);

    // Calculate brightness of the rendered text
    const candidateBrightness = calcBrightness(
      ctx, destinationImage.size.width, destinationImage.size.height
    );

    // Calculate mean squared error between candidate and target
    let mse = 0;
    for (let i = 0; i < destinationImage.bArray.length; i++) {
        const diff = candidateBrightness[i] - destinationImage.bArray[i];
        mse += diff * diff;
    }
    mse /= destinationImage.bArray.length;

    // Return inverse of MSE as fitness score (higher is better)
    // Add a small constant to avoid division by zero
    return 1 / (mse + 0.0001);
};
</file>

<file path="src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="src/main.tsx">
import { render } from 'preact'
import { App } from './app'
import './app.css'

render(<App />, document.getElementById('app')!)
</file>

<file path="src/types.ts">
export type Width = number;
export type Height = number;
export type BrightnessArray = Float32Array;
export interface Position { x: number; y: number; }
export interface Size { width: number; height: number; }

export interface Options {
  // Configuration options for the text-to-image algorithm
  // Contains settings for text blocks, font properties, and algorithm parameters
  // Used to control the appearance and optimization process
  blocks: string[];
  font: {
    family: string;
    minSize: number;
    maxSize: number;
    opacity: number;
    bold: boolean;
    shadow: {
      color: string;
      blur: number;
      offsetX: number;
      offsetY: number;
      enabled: boolean;
    };
  };
  iterations: number;
  generations: number;
}
export interface CurrentImage {
  // Represents the current working image in the optimization process
  // Contains the brightness array and image data for the current state
  // Used to track the evolving image during the genetic algorithm iterations.
  //
  // Size data is not included here because CurrentImage size is always the same as 
  // DestinationImage size.
  //
  // This avoids redundant storage of dimensions that are already available in the DestinationImage
  iData: ImageData;
  size: {
    width: number;
    height: number;
  };
  bArray?: Float32Array;
}
export interface DestinationImage {
  // The destination image properties and data
  // Contains the original image dimensions, brightness array, and image data
  // Used as the target for optimization in the genetic algorithm
  size: Size;
  bArray: BrightnessArray;
  iData: ImageData;
}

export interface Candidate {
  t: string;  // text
  s: number;  // size
  x: number;  // x position
  y: number;  // y position
  o: number;  // opacity
  r: number;  // rotation in radians
  score?: number;
}

export interface ProcessStats {
  // Statistics about the processing progress
  // Tracks the total number of candidates and how many have been processed
  // Used to update the UI with progress information
  total: number;
  processed: number;
}

export type WorkerProcessStats = {
  // Maps worker IDs to their processing statistics
  // Used to track and display the progress of each worker in the pool
  // This allows the UI to show individual worker progress during processing
  [key: number]: ProcessStats;
}

export interface Generation {
  id: number;
  fittest: Candidate;
}

export interface Fittest {
  candidate: Candidate | null;
  score: number;
}

export interface IgniteMessage {
  // Message to initialize a worker with a unique identifier
  // Sent from main thread to worker to start the worker with a specific ID
  // The worker uses this ID for all subsequent communications
  id: number;
  action: "ignite";
}

export interface InitMessage {
  // Message to initialize a worker with source image and configuration
  // Contains all necessary data for the worker to begin processing
  // Includes the destination image, algorithm options, and number of candidates to generate
  // The worker uses this to set up its internal state before processing begins
  workerId?: number;
  action: "init";
  currentImage: CurrentImage;
  destinationImage: DestinationImage;
  options: Options;
  nofCandidates: number;
}

export interface ReadyMessage {
  // Message indicating that a worker is ready for processing
  // Sent from worker to main thread after successful initialization
  // Signals that the worker can now accept processing tasks
  action: "ready";
}

export interface UpdateMessage {
  // Message to report progress during processing
  // Sent periodically from worker to main thread
  // Used to update UI with current processing status
  action: "update";
  total: number;
  processed: number;
}

export interface ProcessMessage {
  // Message to instruct a worker to begin processing its candidates
  // Sent from main thread to worker to start the fitness calculation
  // Triggers the worker to evaluate all its candidates
  action: "process";
}

export interface DoneMessage {
  // Message indicating that a worker has completed processing
  // Contains the fittest candidate found by this worker
  // Sent from worker to main thread when all candidates have been evaluated
  action: "done";
  fittest: Fittest;
}

export interface InitializedMessage {
  action: "initialized"
}

export interface ErrorMessage {
  // Message to report an error during worker processing
  // Contains a description of what went wrong
  // Used for error handling and debugging
  action: "error";
  reason: string;
}

export interface BaseMessage {
  // Base properties included in all worker messages
  // Provides timing information and worker identification
  // Used for tracking and debugging message flow
  timestamp: number;
  workerId: number;
}

export type WorkerMessage = 
  // Union type of all possible messages that can be exchanged with workers
  // Each message type extends BaseMessage to include common properties
  // Used for type-safe communication between main thread and workers
  | (IgniteMessage & BaseMessage)
  | (InitMessage & BaseMessage)
  | (ReadyMessage & BaseMessage)
  | (UpdateMessage & BaseMessage)
  | (ProcessMessage & BaseMessage)
  | (DoneMessage & BaseMessage)
  | (ErrorMessage & BaseMessage)
  | (InitializedMessage & BaseMessage);

export interface WorkerTask {
  candidates: Candidate[];
  batchInfo: {
    batchId: number;
    startIndex: number;
  };
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src/worker.ts">
/**
 * Web Worker for processing text rendering and fitness calculations
 * This worker handles the optimization of text placement and styling
 * to match a target image using a genetic algorithm approach.
 */

import { DestinationImage, Candidate, WorkerMessage, CurrentImage, Options, InitMessage, BaseMessage } from './types';
import { generateCandidates, calcFitness } from './helpers';

let id: number;
let currentImage: CurrentImage;
let options: Options;
let destinationImage: DestinationImage;
let candidates: Candidate[];
let canvas: OffscreenCanvas;

function handleIgnite(data: WorkerMessage) {
  if (data.workerId === undefined) {
    self.postMessage({
      action: 'error',
      reason: 'You need to send workerId to ignite a worker.',
      timestamp: Date.now(),
      workerId: -1
    });
    return;
  }
  id = data.workerId;
  canvas = new OffscreenCanvas(1, 1); // Default size, will be updated when source is received
  self.postMessage({ 
    action: 'ready', 
    timestamp: Date.now(), 
    workerId: id 
  });
}

function handleInit(data: InitMessage & BaseMessage) {
  if (!data) {
    self.postMessage({
      action: 'error',
      reason: 'The source, destination, options and number of candidates must be sent in data',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }
  if (!data.currentImage) {
    self.postMessage({
      action: 'error',
      reason: 'No current image provided for initialization',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }
  if (!data.destinationImage) {
    self.postMessage({
      action: 'error',
      reason: 'No destination provided for initialization',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }
  if (!data.nofCandidates) {
    self.postMessage({
      action: 'error',
      reason: 'nofCandidates not provided for initialization',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }
  if (!data.options) {
    self.postMessage({
      action: 'error',
      reason: 'options not provided for initialization',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }
  currentImage = data.currentImage;
  destinationImage = data.destinationImage;
  options = data.options;
  canvas.width = destinationImage.size.width;
  canvas.height = destinationImage.size.height;
  candidates = generateCandidates(destinationImage, data.options, data.nofCandidates);
  self.postMessage({ 
    action: 'initialized', 
    timestamp: Date.now(),
    workerId: id
  });
}
function handleProcess() {
  if (!candidates || candidates.length === 0) {
    self.postMessage({
      action: 'error',
      reason: 'No candidates to process. Init must be called first to generate candidates.',
      timestamp: Date.now(),
      workerId: id
    });
    return;
  }

  // Calculate the fittest.
  let fittest;
  for (let i = 0; i < candidates.length; i++) {
    self.postMessage({ 
      action: 'update', 
      total: candidates.length, 
      processed: i, 
      timestamp: Date.now(), 
      workerId: id 
    });
    const candidate = {...candidates[i], score: calcFitness(currentImage, candidates[i], destinationImage, options)}
    if (fittest === undefined) { fittest = candidate; continue; }
    if (fittest.score <= candidate.score) { fittest = candidate; continue; }
  }

  self.postMessage({
    action: 'done',
    fittest: {
      candidate: fittest,
      score: fittest!.score || 0
    },
    timestamp: Date.now(),
    workerId: id
  });
}

// Handle messages from the main thread
self.onmessage = (e: MessageEvent<WorkerMessage>) => {
  const { data } = e;
  const { action } = data;

  console.log(`Worker ${id} received action: ${action}`, data);

  switch (action) {
    case "ignite":
      handleIgnite(data);
      break;
    case "init":
      handleInit(data as InitMessage & BaseMessage);
      break;
    case "process":
      handleProcess();
      break;
  }
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact()],
})
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="package.json">
{
  "name": "geneticletterdraw",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.26.4"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.10.1",
    "typescript": "~5.7.2",
    "vite": "^6.3.1"
  }
}
</file>

<file path="test_image.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
    <!-- Black rectangle on the left -->
    <rect x="0" y="0" width="200" height="400" fill="black"/>
    <!-- White rectangle on the right -->
    <rect x="200" y="0" width="200" height="400" fill="white"/>
</svg>
</file>

<file path="index.css">
@font-face {
  font-family: Dos;
  src: url(https://mirat.dev/dos.ttf);
}

:root {
  --c0: #000000;
  --c1: #000080;
  --c2: #00aaaa;
  --c3: #0f110f;
  --c4: #aa00aa;
  --c5: #aa0000;
  --c6: #aa5500;
  --c7: #aaaaaa;
  --c8: #555555;
  --c9: #5555ff;
  --c10: #1fdbdb;
  --c12: #55ff55;
  --c12: #ff55ff;
  --c13: #ff5555;
  --c14: #ffff55;
  --c15: #ffffff;
  --ln: 2px;
  --gap: 1rem;
  --fs: 16px;
  --lh: 24px;
}

em {
  color: var(--c6);
  font-style: normal;
}

strong {
  font-weight: normal;
  color: var(--c15);
}

::-webkit-scrollbar {
  width: var(--gap)
}

::-webkit-scrollbar-track {
  background: var(--c7);
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: var(--c8);
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: var(--c4);
}

.screen *:not(pre) {
  font-size: inherit;
  line-height: inherit;
}

.wrapper {
  max-width: 800px;
  margin: 0 auto;
}

html,
body {
  margin: 0;
  padding: 0;
}

body {
  background: var(--c0);
  color: var(--c7);
  font-family: 'Dos', monospace;
  font-size: var(--fs);
  line-height: var(--lh);
  vertical-align: center;
  font-smooth: never;
  -webkit-font-smoothing: none;
  letter-spacing: -1px;
}

pre {
  font-family: inherit;
  padding: 1rem;
  background: #111;
  border: 1px solid gray;
  overflow-y: scroll;
}

code {
  color: var(--c3);
  font-family: inherit;
}

h1,
h2,
h3,
h4,
h5,
p,
li,
table,
blockquote {
  font-weight: normal;
  margin: 0 0 1rem 0;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  letter-spacing: inherit;
}

li {
  margin: 0;
}

h1 {
  font-size: 1.4em;
  line-height: 1.73em;
  text-transform: uppercase;
  text-align: center;
}

h2 {
  font-size: 1.3em;
  line-height: 1.61em;
  border-bottom: 4px double var(--c4);
}

h3 {
  line-height: 1.48em;
}

h1,
h2,
h3 {
  color: var(--c14);
}

blockquote {
  padding: 0 1em;
  border-left: 2px solid #B2A497;
  border-bottom: 2px solid #B2A497;
}

.youtube-video {
  aspect-ratio: 16 / 9;
  width: 100%;
}

ul#articles li {
  list-style-type: square;
  color: var(--c2);
}

ul#articles {
  padding: 0 0 0 1em;
}

nav a {
  text-decoration: none;
  color: var(--c0);
}

nav a span {
  color: var(--c5);
}

a.active {
  text-decoration: underline;
}

a.tag {
  color: darkolivegreen;
  justify-content: center;
}

main,
header {
  margin: 0 auto;
  box-sizing: border-box;
}

main {
  margin: 1rem 0;
  padding: 0 1rem;
}

main a {
  color: var(--c10);
  text-decoration: underline;
}

nav {
  background: var(--c7);
  padding: 0 1rem;
}

nav .wrapper {
  display: flex;
  align-content: center;
  gap: 0 1rem;
  flex-wrap: wrap;

}

main nav,
table {
  background: transparent;
  padding: 1rem;
  border: 4px double var(--c3);
  margin: 0 auto;
}

main nav a {
  /* color: var(--c2); */
}

.pagination {
  text-align: center;
}

p:has(> img:only-child) {
  display: flex;
  justify-content: center;
  border: calc(var(--ln) * 2) double var(--c3)
}

img {
  max-width: 80%;
}

input, textarea, select, button {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  background: var(--c0);
  color: var(--c7);
  border: 2px solid var(--c8);
  padding: 0.5rem;
  margin: 0;
  display: block;
  box-sizing: border-box;
  width: 100%;
}

input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: var(--c10);
}

button {
  background: var(--c8);
  color: var(--c15);
  cursor: pointer;
  padding: 0.5rem 1rem;
  border: none;
}

button:not(:disabled) {
  background: var(--c2);
}

button:hover:not(:disabled) {
  background: var(--c4);
}

button:disabled {
  background: var(--c8);
  cursor: not-allowed;
  opacity: 0.7;
}

input[type="checkbox"], input[type="radio"] {
  width: 1rem;
  height: 1rem;
  margin-right: 0.5rem;
  vertical-align: middle;
}

input[type="range"] {
  -webkit-appearance: none;
  background: var(--c8);
  height: 10px;
  padding: 0;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  background: var(--c7);
  cursor: pointer;
}

@media only screen and (max-width: 500px) {

  header,
  main {
    padding: 1em;
  }

  ul#articles li a {
    display: block
  }
}

main> :first-child {
  margin-top: 0;
}

.row {
  display: flex;
  flex-wrap: nowrap;
  margin: 0 0 10px 0;
  gap: 10px;
}

.col-6 {
  width: calc(50% - 5px);
}

.inputs {
  flex-basis: 300px;
}

.button-group {
  display: flex;
  justify-content: space-between;
}
.button-group > * {
  width: 100%;
}
progress {
  width: 100%;
  height: 20px;
  border-radius: 0;
  background-color: var(--c7);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: relative;
  overflow: hidden;
  border-bottom: 2px;
}

progress::-webkit-progress-bar {
  background-color: var(--c7);
}

progress::-webkit-progress-value {
  background-color: var(--c10);
}
.control-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: auto auto;
  grid-gap: 5px;
  grid-template-areas: 
    "start stop reset"
    "progress progress progress"
    "download download download";
}

.control-grid #startButton {
  grid-area: start;
}

.control-grid #stopButton {
  grid-area: stop;
}

.control-grid #resetButton {
  grid-area: reset;
}

.control-grid #progress {
  grid-area: progress;
}

.control-grid #downloadButton {
  grid-area: download;
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Preact + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

</files>
