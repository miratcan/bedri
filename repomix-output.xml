This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
index.css
index.html
index.js
test_image.svg
worker.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
/node_modules
/node_modules
</file>

<file path="test_image.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
    <!-- Black rectangle on the left -->
    <rect x="0" y="0" width="200" height="400" fill="black"/>
    <!-- White rectangle on the right -->
    <rect x="200" y="0" width="200" height="400" fill="white"/>
</svg>
</file>

<file path="index.css">
@font-face {
  font-family: Dos;
  src: url(https://mirat.dev/dos.ttf);
}

:root {
  --c0: #000000;
  --c1: #000080;
  --c2: #00aaaa;
  --c3: #0f110f;
  --c4: #aa00aa;
  --c5: #aa0000;
  --c6: #aa5500;
  --c7: #aaaaaa;
  --c8: #555555;
  --c9: #5555ff;
  --c10: #1fdbdb;
  --c12: #55ff55;
  --c12: #ff55ff;
  --c13: #ff5555;
  --c14: #ffff55;
  --c15: #ffffff;
  --ln: 2px;
  --gap: 1rem;
  --fs: 16px;
  --lh: 24px;
}

em {
  color: var(--c6);
  font-style: normal;
}

strong {
  font-weight: normal;
  color: var(--c15);
}

::-webkit-scrollbar {
  width: var(--gap)
}

::-webkit-scrollbar-track {
  background: var(--c7);
}

/* Handle */
::-webkit-scrollbar-thumb {
  background: var(--c8);
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  background: var(--c4);
}

.screen *:not(pre) {
  font-size: inherit;
  line-height: inherit;
}

.wrapper {
  max-width: 800px;
  margin: 0 auto;
}

html,
body {
  margin: 0;
  padding: 0;
}

body {
  background: var(--c0);
  color: var(--c7);
  font-family: 'Dos', monospace;
  font-size: var(--fs);
  line-height: var(--lh);
  vertical-align: center;
  font-smooth: never;
  -webkit-font-smoothing: none;
  letter-spacing: -1px;
}

pre {
  font-family: inherit;
  padding: 1rem;
  background: #111;
  border: 1px solid gray;
  overflow-y: scroll;
}

code {
  color: var(--c3);
  font-family: inherit;
}

h1,
h2,
h3,
h4,
h5,
p,
li,
table,
blockquote {
  font-weight: normal;
  margin: 0 0 1rem 0;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  letter-spacing: inherit;
}

li {
  margin: 0;
}

h1 {
  font-size: 1.4em;
  line-height: 1.73em;
  text-transform: uppercase;
  text-align: center;
}

h2 {
  font-size: 1.3em;
  line-height: 1.61em;
  border-bottom: 4px double var(--c4);
}

h3 {
  line-height: 1.48em;
}

h1,
h2,
h3 {
  color: var(--c14);
}

blockquote {
  padding: 0 1em;
  border-left: 2px solid #B2A497;
  border-bottom: 2px solid #B2A497;
}

.youtube-video {
  aspect-ratio: 16 / 9;
  width: 100%;
}

ul#articles li {
  list-style-type: square;
  color: var(--c2);
}

ul#articles {
  padding: 0 0 0 1em;
}

nav a {
  text-decoration: none;
  color: var(--c0);
}

nav a span {
  color: var(--c5);
}

a.active {
  text-decoration: underline;
}

a.tag {
  color: darkolivegreen;
  justify-content: center;
}

main,
header {
  margin: 0 auto;
  box-sizing: border-box;
}

main {
  margin: 1rem 0;
  padding: 0 1rem;
}

main a {
  color: var(--c10);
  text-decoration: underline;
}

nav {
  background: var(--c7);
  padding: 0 1rem;
}

nav .wrapper {
  display: flex;
  align-content: center;
  gap: 0 1rem;
  flex-wrap: wrap;

}

main nav,
table {
  background: transparent;
  padding: 1rem;
  border: 4px double var(--c3);
  margin: 0 auto;
}

main nav a {
  /* color: var(--c2); */
}

.pagination {
  text-align: center;
}

p:has(> img:only-child) {
  display: flex;
  justify-content: center;
  border: calc(var(--ln) * 2) double var(--c3)
}

img {
  max-width: 80%;
}

input, textarea, select, button {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  background: var(--c0);
  color: var(--c7);
  border: 2px solid var(--c8);
  padding: 0.5rem;
  margin: 0;
  display: block;
  box-sizing: border-box;
  width: 100%;
}

input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: var(--c10);
}

button {
  background: var(--c8);
  color: var(--c15);
  cursor: pointer;
  padding: 0.5rem 1rem;
  border: none;
}

button:not(:disabled) {
  background: var(--c2);
}

button:hover:not(:disabled) {
  background: var(--c4);
}

button:disabled {
  background: var(--c8);
  cursor: not-allowed;
  opacity: 0.7;
}

input[type="checkbox"], input[type="radio"] {
  width: 1rem;
  height: 1rem;
  margin-right: 0.5rem;
  vertical-align: middle;
}

input[type="range"] {
  -webkit-appearance: none;
  background: var(--c8);
  height: 10px;
  padding: 0;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  background: var(--c7);
  cursor: pointer;
}

@media only screen and (max-width: 500px) {

  header,
  main {
    padding: 1em;
  }

  ul#articles li a {
    display: block
  }
}

main> :first-child {
  margin-top: 0;
}

.row {
  display: flex;
  flex-wrap: nowrap;
  margin: 0 0 10px 0;
  gap: 10px;
}

.col-6 {
  width: calc(50% - 5px);
}

.inputs {
  flex-basis: 300px;
}

.button-group {
  display: flex;
  justify-content: space-between;
}
.button-group > * {
  width: 100%;
}
progress {
  width: 100%;
  height: 20px;
  border-radius: 0;
  background-color: var(--c7);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: relative;
  overflow: hidden;
  border-bottom: 2px;
}

progress::-webkit-progress-bar {
  background-color: var(--c7);
}

progress::-webkit-progress-value {
  background-color: var(--c10);
}
.control-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: auto auto;
  grid-gap: 5px;
  grid-template-areas: 
    "start stop reset"
    "progress progress progress"
    "download download download";
}

.control-grid #startButton {
  grid-area: start;
}

.control-grid #stopButton {
  grid-area: stop;
}

.control-grid #resetButton {
  grid-area: reset;
}

.control-grid #progress {
  grid-area: progress;
}

.control-grid #downloadButton {
  grid-area: download;
}
</file>

<file path="worker.js">
// worker.js - Updated with init handshake and safety checks

self.onmessage = function (e) {
  const { action, data } = e.data;
  console.log(`Worker received action: ${action}`);

  if (action === "initialize") {
    console.log("Initializing worker with image data and options.");
    // Store image data, dimensions, etc.
    self.srcWidth = data.srcWidth;
    self.srcHeight = data.srcHeight;
    self.srcBArray = data.srcBArray;
    self.options = data.options;

    // Confirm readiness to main thread
    self.postMessage({ action: "ready" });
    console.log("Worker initialized and ready.");
  } else if (action === "processLine") {
    // Check if initialized
    if (!self.srcWidth || !self.srcHeight) {
      console.warn("Worker received task before initialization.");
      return self.postMessage({
        action: "lineProcessed",
        result: { bestCandidate: null, bestFitness: -Infinity },
      });
    }

    console.log("Processing line in worker.");
    const result = processLineWorker(data);
    self.postMessage({ action: "lineProcessed", result });
    console.log("Line processed and result sent back.");
  }
};

function calcBrightness(imageData) {
  const totalPixels = self.srcWidth * self.srcHeight;
  let result = new Float32Array(totalPixels);
  for (let i = 0; i < totalPixels; i++) {
    const pixelIndex = i * 4;
    const r = imageData[pixelIndex];
    const g = imageData[pixelIndex + 1];
    const b = imageData[pixelIndex + 2];
    result[i] = 0.299 * r + 0.587 * g + 0.114 * b;
  }
  return result;
}

function calculateFitness(dstBArr) {
  let sum = 0;
  for (let i = 0; i < self.srcWidth * self.srcHeight; i++) {
    sum += Math.abs(dstBArr[i] - self.srcBArray[i]);
  }
  return self.srcWidth * self.srcHeight * 255 - sum;
}

function processLineWorker({ line, canvasData, iterations, minSize, maxSize, color }) {
  console.log(`Processing line: ${line}`);
  const canvas = new OffscreenCanvas(self.srcWidth, self.srcHeight);
  const ctx = canvas.getContext("2d");

  const imageData = new ImageData(new Uint8ClampedArray(canvasData), self.srcWidth, self.srcHeight);
  ctx.putImageData(imageData, 0, 0);

  let bestFitness = -Infinity;
  let bestCandidate = null;

  for (let i = 0; i < iterations; i++) {
    const fontSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
    const x = Math.random() * self.srcWidth;
    const y = Math.random() * self.srcHeight;
    const rotation = (Math.random() * Math.PI) - (Math.PI / 2);

    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);

    const testCtx = new OffscreenCanvas(self.srcWidth, self.srcHeight).getContext("2d");
    testCtx.drawImage(canvas, 0, 0);
    testCtx.save();
    testCtx.translate(x, y);
    testCtx.rotate(rotation);
    testCtx.shadowColor = "black";
    testCtx.shadowBlur = 10;
    testCtx.font = `${fontSize}px Arial`;
    testCtx.fillStyle = color;
    testCtx.textAlign = "center";
    testCtx.textBaseline = "middle";
    testCtx.fillText(line, 0, 0);
    const testData = testCtx.getImageData(0, 0, self.srcWidth, self.srcHeight);
    const dstBArr = calcBrightness(testData.data);
    const fitness = calculateFitness(dstBArr);
    testCtx.restore();

    if (fitness > bestFitness) {
      bestFitness = fitness;
      bestCandidate = { x, y, fontSize, rotation, color, line };
    }
  }

  console.log(`Best candidate for line: ${line} with fitness: ${bestFitness}`);
  return { bestCandidate, bestFitness };
}
</file>

<file path="index.js">
// === Full index.js ===

"use strict";

const pF = parseFloat;
const pI = parseInt;
const gebID = id => document.getElementById(id);
const mF = Math.floor;
const mR = Math.random;
const maxPixelSize = 1000000;

const randColor = () => {
  const h = Math.floor(mR() * 360); // Hue: 0-360
  const s = 10 + mR() * 90; // Saturation: 50-100%
  const l = mR() * 100; // Lightness: 0-100%
  return `hsla(${h}, ${s}%, ${l}%, ${options.opacity})`;
};

let processing = false;
let imageLoaded = false;
let lastBestFitness = 0;
let lineIndex = 0;
let linesCount = 0;

let srcWidth = null;
let srcHeight = null;
let srcBArray = null;

const imgInp = gebID("imageInput");
const linesInp = gebID("lines");
const minSizeInp = gebID("minSize");
const maxSizeInp = gebID("maxSize");
const opacityInp = gebID("opacity");
const iterInp = gebID("iterations");
const nofLinesInp = gebID("nofLines");
const sRateInp = gebID("sampleRate");

const startButton = gebID("startButton");
const stopButton = gebID("stopButton");
const resetButton = gebID("resetButton");
const downloadButton = gebID("downloadButton");
const progressBar = gebID("progress");

const srcCanvas = gebID("srcCanvas");
const srcCtx = srcCanvas.getContext("2d", { willReadFrequently: true });
const srcInfo = gebID("srcInfo");

const cdtCanvas = document.createElement("canvas");
const cdtCtx = cdtCanvas.getContext("2d", { willReadFrequently: true });

const dstCanvas = gebID("dstCanvas");
const dstCtx = dstCanvas.getContext("2d", { willReadFrequently: true });

function readOptions() {
  return {
    lines: linesInp.value.trim().split(/\n+/),
    minSize: pI(minSizeInp.value),
    maxSize: pI(maxSizeInp.value),
    opacity: pF(opacityInp.value),
    iterations: pI(iterInp.value),
    wordCount: pI(nofLinesInp.value || 2500)
  };
}

function calcBrightness(ctx) {
  const pixelData = ctx.getImageData(0, 0, srcWidth, srcHeight).data;
  const totalPixels = srcWidth * srcHeight;
  let result = new Float32Array(totalPixels);
  for (let i = 0; i < totalPixels; i++) {
    const pixelIndex = i * 4;
    const r = pixelData[pixelIndex];
    const g = pixelData[pixelIndex + 1];
    const b = pixelData[pixelIndex + 2];
    result[i] = 0.299 * r + 0.587 * g + 0.114 * b;
  }
  return result;
}

imgInp.addEventListener("change", handleImageUpload);
startButton.addEventListener("click", startProcessing);
stopButton.addEventListener("click", reset);
resetButton.addEventListener("click", reset);
downloadButton.addEventListener("click", downloadImage);

function handleImageUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function (event) {
    const img = new Image();
    img.onload = function () {
      if (img.width * img.height > maxPixelSize) {
        alert(`Warning: Image dimensions (${img.width}x${img.height}) are large.`);
      }

      srcInfo.textContent = `Dimensions: ${img.width} Ã— ${img.height} pixels`;
      srcWidth = img.width;
      srcHeight = img.height;

      srcCanvas.width = srcWidth;
      srcCanvas.height = srcHeight;
      dstCanvas.width = srcWidth;
      dstCanvas.height = srcHeight;
      cdtCanvas.width = srcWidth;
      cdtCanvas.height = srcHeight;
      srcCanvas.style.width = '100%'
      srcCanvas.style.height = 'auto'
      dstCanvas.style.width = '100%'
      dstCanvas.style.height = 'auto'

      srcCtx.drawImage(img, 0, 0);
      srcBArray = calcBrightness(srcCtx);
      imageLoaded = true;
      startButton.disabled = false;
      dstCtx.fillStyle = "black";
      dstCtx.fillRect(0, 0, srcWidth, srcHeight);

      console.log(`Image uploaded: ${img.width}x${img.height}`);
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
}

function downloadImage() {
  const link = document.createElement("a");
  link.href = dstCanvas.toDataURL("image/png");
  link.download = "textdraw.png";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function startProcessing() {
  if (!imageLoaded) {
    alert("Please upload an image first.");
    return;
  }

  if (!processing) {
    options = readOptions();
    if (options.minSize >= options.maxSize) {
      alert("Minimum font size must be less than maximum font size.");
      return;
    }

    lineIndex = 0;
    linesCount = options.wordCount;
    dstCtx.fillStyle = "black";
    dstCtx.fillRect(0, 0, srcWidth, srcHeight);

    startButton.disabled = true;
    stopButton.disabled = false;
    resetButton.disabled = true;
    processing = true;

    minSizeInp.disabled = true;
    maxSizeInp.disabled = true;
    opacityInp.disabled = true;
    linesInp.disabled = true;
    nofLinesInp.disabled = true;
    sRateInp.disabled = true;

    console.log('Processing started with options:', options);

    processLoop();
  }
}

function reset() {
  processing = false;
  lastBestFitness = 0;

  minSizeInp.disabled = false;
  maxSizeInp.disabled = false;
  opacityInp.disabled = false;
  linesInp.disabled = false;
  nofLinesInp.disabled = false;
  sRateInp.disabled = false;

  if (imageLoaded) {
    dstCtx.clearRect(0, 0, srcWidth, srcHeight);
    dstCtx.fillStyle = "black";
    dstCtx.fillRect(0, 0, srcWidth, srcHeight);
  }

  lineIndex = 0;
  updateProgress();
  startButton.disabled = !imageLoaded;
  stopButton.disabled = true;
  resetButton.disabled = false;

  console.log('Reset called');
}

function updateProgress() {
  const progress = lineIndex / linesCount;
  progressBar.value = progress * 100;
  const progressPercent = mF(progress * 100);
  document.title = `TextCanvas: ${progressPercent}% Complete`;

  console.log(`Progress updated: ${progressPercent}%`);
}

// === Worker Pool Implementation ===

let workerCount = navigator.hardwareConcurrency || 4;
let workers = [];
let activeTasks = 0;
let finishedTasks = 0;
let workerInitialized = false;
let options = {};

function initializeWorkerPool() {
  if (workerInitialized) return;
  workerInitialized = true;

  for (let i = 0; i < workerCount; i++) {
    const worker = new Worker("worker.js");
    worker.ready = false;

    worker.onmessage = function (e) {
      const { action, result } = e.data;

      if (action === "ready") {
        worker.ready = true;
        tryStartNextTask(worker);
        return;
      }

      if (action === "lineProcessed") {
        if (result.bestCandidate) {
          const { x, y, fontSize, rotation, color, line } = result.bestCandidate;
          dstCtx.save();
          dstCtx.translate(x, y);
          dstCtx.rotate(rotation);
          dstCtx.shadowColor = "black";
          dstCtx.shadowBlur = 10;
          dstCtx.font = `${fontSize}px Arial`;
          dstCtx.fillStyle = color;
          dstCtx.strokeStyle = 'black';
          dstCtx.textAlign = "center";
          dstCtx.textBaseline = "middle";
          dstCtx.fillText(line, 0, 0);
          dstCtx.restore();
          lastBestFitness = result.bestFitness;
        }

        lineIndex++;
        finishedTasks++;
        updateProgress();
        activeTasks--;

        if (processing && lineIndex < linesCount) {
          tryStartNextTask(worker);
        } else if (!processing || finishedTasks >= linesCount) {
          processing = false;
          startButton.disabled = false;
          stopButton.disabled = true;
          resetButton.disabled = false;
        }
      }
    };

    workers.push(worker);

    worker.postMessage({
      action: "initialize",
      data: {
        srcWidth,
        srcHeight,
        srcBArray,
        options,
      },
    });

    console.log(`Worker ${i} initialized`);
  }
}

function tryStartNextTask(worker) {
  if (!worker.ready || !processing || lineIndex >= linesCount) return;
  assignTask(worker);
}

function assignTask(worker) {
  const line = options.lines[mF(mR() * options.lines.length)];
  const imageData = dstCtx.getImageData(0, 0, srcWidth, srcHeight);

  worker.postMessage(
    {
      action: "processLine",
      data: {
        line,
        canvasData: imageData.data.buffer,
        iterations: options.iterations,
        minSize: options.minSize,
        maxSize: options.maxSize,
        color: randColor(),
      },
    },
    [imageData.data.buffer]
  );

  activeTasks++;

  console.log(`Task assigned to worker with line: ${line}`);
}

function processLoop() {
  if (!processing) return;
  initializeWorkerPool();
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>TextDraw: Image-to-Text Renderer</title>
	<link rel="stylesheet" href="index.css" />
	<script type="text/javascript">
		(function (c, l, a, r, i, t, y) {
			c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments); };
			t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
			y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
		})(window, document, "clarity", "script", "r4oy6342f7");
	</script>
</head>

<body>
	<header>
		<nav>
			<div class="wrapper">
				<a class="active" href="/"><span>T</span>extDraw</a>
				<a href="https://github.com/miratcan/textdraw/"><span>G</span>ithub</a>
			</div>
		</nav>
	</header>
	<main>
		<div class="wrapper">
			<p><strong>TextDraw</strong> is a tool that converts images into text-based representations. It uses a combination
				of image processing and text rendering to create a unique visual representation of the input image.</p>
			<p>Select an image, adjust the settings, and click <strong>Start</strong>. The algorithm will place text blocks
				from the textarea onto the image, attempting to match the brightness patterns of the original. <strong>Larger
					images may take longer to process</strong>. You can stop at any time and download the result as a PNG file.
			</p>
			<p>Please be patient as this application processes images using <strong>CPU-intensive algorithms</strong>. Larger
				images and more complex settings will require more processing time. You can monitor progress in the bar below
				and feel free to switch to other browser tabs while rendering is in progress. For <strong>optimal
					performance</strong>, use smaller images (under 1000x1000 pixels) and fewer text blocks.</p>
			<div class="row">
				<section class="card inputs col">
					<fieldset>
						<legend>Source</legend>
						<div class="input-group">
							<label for="imageInput">Input Image:</label>
							<input type="file" id="imageInput" accept="image/*" class="input" />
							<p id="srcInfo" class="helptext">Loaded image etc...</p>
						</div>
						<div class="input-group">
							<label for="wordList">Text Blocks:</label>
							<textarea id="lines" class="input"
								placeholder="Enter text blocks, one per line. Each line will be treated as a separate block of text.">Words In This
Will be used
to draw the
image.</textarea>
						</div>
					</fieldset>
					<fieldset>
						<legend>Controls</legend>
						<div class="control-grid">
							<button id="startButton" class="button primary">Start</button>
							<button id="stopButton" class="button" disabled>Stop</button>
							<button id="resetButton" class="button error">Reset</button>
							<progress id="progress" class="grow" max="100" value="0"></progress>
							<Button id="downloadButton">Download</Button>
						</div>
					</fieldset>
					<fieldset>
						<legend>Font</legend>
						<div class="input-group">
							<label for="minSize">Min Size: <span id="minSizeValue">12</span>px</label>
							<input type="range" id="minSize" min="8" max="40" value="12" step="1" class="input"
								oninput="document.getElementById('minSizeValue').textContent = this.value" />
						</div>
						<div class="input-group">
							<label for="maxSize">Max Size: <span id="maxSizeValue">24</span>px</label>
							<input type="range" id="maxSize" min="12" max="360" value="24" step="1" class="input"
								oninput="document.getElementById('maxSizeValue').textContent = this.value" />
						</div>
						<div class="input-group">
							<label for="opacity">Opacity: <span id="opacityValue">0.4</span></label>
							<input type="range" id="opacity" min="0.1" max="1" value="0.4" step="0.1" class="input"
								oninput="document.getElementById('opacityValue').textContent = this.value" />
						</div>
					</fieldset>
					<fieldset>
						<legend>Performance</legend>
						<div class="input-group">
							<label for="iterations">Number of Lines:</label>
							<input type="number" id="nofLines" min="100" max="10000" value="2500" class="input" />
							<!--
							<p class="helptext">Specify the total number of lines to be placed on the image. More words
								will
								create a more detailed result but take longer to process.</p>
							!-->
						</div>
						<div class="input-group">
							<label for="iterations">Iterations:</label>
							<input type="number" id="iterations" min="1" max="1000" value="20" class="input" />
							<!--
							<p class="helptext">
								Specify the number of iterations for word placement optimization.
								Higher values may improve the result but increase processing time.
							</p>
							!-->
						</div>
						<div class="input-group">
							<label for="sampleRate">Sample Rate(<a href="#">?</a>)</label>
							<input type="number" id="sampleRate" min="1" max="20" value="4" class="input" />
							<!--
							<p class="helptext">
								Controls how frequently pixels are sampled from the image.
								Higher values improve quality but increase processing time.
							</p>
							!-->
						</div>
					</fieldset>
				</section>
				<section class="col grow">
					<div class="card">
						<h2>Source</h2>
						<canvas id="srcCanvas"></canvas>
					</div>
					<div class="card">
						<h2>Result</h2>
						<canvas id="dstCanvas"></canvas>
					</div>
					<h2>Examples:</h2>
					<div class="row">
						<img src="https://placehold.co/300x300" />
					</div>
				</section>
			</div>
		</div>
	</main>
	<script src="index.js"></script>
</body>

</html>
</file>

</files>
